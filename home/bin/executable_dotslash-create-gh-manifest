#!/usr/bin/env -S deno run --allow-net --allow-read --allow-write --ext=ts

// Script to generate a DotSlash manifest for a GitHub release
// Usage: $0 owner/repo tag_name asset_pattern


import { blake3 } from "npm:@noble/hashes/blake3";
import { bytesToHex } from "npm:@noble/hashes/utils";
import { parseArgs } from "jsr:@std/cli";
import $ from "jsr:@david/dax";
const { dedent } = $;

interface GithubRelease {
  tag_name: string;
  assets: Array<{
    name: string;
    size: number;
    browser_download_url: string;
  }>;
}

interface Platform {
  arch: string;
  os: string;
  pattern: (name: string) => boolean;
}

type Pattern = string[]
const containsAny = (patterns: Pattern) => (name: string) => patterns.some(pattern => name.includes(pattern))
const containsAll = (patterns: Pattern[]) => (name: string) => patterns.every(p => containsAny(p)(name))

const X86 = ["x64", "amd64", "x86_64"]
const ARM = ["arm64", "aarch64"]

const Apple = ["apple", "darwin", "macos"]
const Linux = ["linux"]

const PLATFORMS: Platform[] = [
  {
    arch: "aarch64",
    os: "linux",
    pattern: containsAll([Linux, ARM])
  },
  {
    arch: "x86_64",
    os: "linux",
    pattern: containsAll([Linux, X86])
  },
  {
    arch: "aarch64",
    os: "macos",
    pattern: containsAll([Apple, ARM])
  },
  {
    arch: "x86_64",
    os: "macos",
    pattern: containsAll([Apple, X86])
  },
];

async function getBlake3Hash(url: string): Promise<string> {
  const response = await fetch(url);
  const data = new Uint8Array(await response.arrayBuffer());

  const hash = blake3(data);
  return bytesToHex(hash);
}

type DotSlashFormat = "tar.gz" | "tar.xz" | "tar.zst" | "tar" | "zip" | "gz" | "xz" | "zst" | undefined;

// Check for officially supported formats
const supportedFormats: DotSlashFormat[] = [
  "tar.gz",
  "tar.xz",
  "tar.zst",
  "tar",
  "zip",
  "gz",
  "xz",
  "zst"
];

function getAssetFormat(filename: string): DotSlashFormat {
  // Handle common alternative extensions first
  if (filename.endsWith(".tgz")) {
    return "tar.gz";
  }


  for (const format of supportedFormats) {
    if (filename.endsWith(`.${format}`)) {
      return format;
    }
  }

  // If no format is detected, return undefined
  // This will cause the format field to be omitted
  return undefined;
}

async function generateDotSlashManifest(
  owner: string,
  repo: string,
  tag: string,
  assetPattern: string
): Promise<void> {
  const releaseUrl = `https://api.github.com/repos/${owner}/${repo}/releases/tags/${tag}`;

  const response = await fetch(releaseUrl);
  if (!response.ok) {
    throw new Error(`Failed to fetch release: ${response.statusText}`);
  }

  const release: GithubRelease = await response.json();

  const manifest = {
    name: repo,
    platforms: {} as Record<string, any>,
    metadata: {} as Record<string, any>,
  };

  const buildScript = Deno.mainModule.split("/").pop();

  for (const platform of PLATFORMS) {
    const asset = release.assets.find(a =>
      a.name.match(assetPattern) && platform.pattern(a.name.toLowerCase())
    );

    if (asset) {
      const platformKey = `${platform.os}-${platform.arch}`;
      const hash = await getBlake3Hash(asset.browser_download_url);

      manifest.platforms[platformKey] = {
        size: asset.size,
        hash: "blake3",
        digest: hash,
        path: `${repo}`, // TODO: allow specifying the path
        format: getAssetFormat(asset.name),
        providers: [
          {
            type: "github-release",
            repo: `${owner}/${repo}`,
            tag: release.tag_name,
            name: asset.name
          }
        ],
        readonly: true
      };
    }
  }
  manifest.metadata = {
    build_info: {
      created_at: new Date().toISOString(),
      build_tool: buildScript,
    }
  };
  // Write the manifest with the required shebang
  const output = dedent`
  #!/usr/bin/env dotslash

  // Generated by ${buildScript} using
  // ${buildScript} ${args._.join(" ")}

  ${JSON.stringify(manifest, null, 2)}
  `

  // TODO: allow specifying the output location including stdout
  await Deno.writeTextFile(`${repo}`, output);
  await Deno.chmod(`${repo}`, 0o755);
}

// Parse command line arguments
const args = parseArgs(Deno.args, {});

if (args._.length !== 3) {
  console.error("Usage: $0 owner/repo tag_name asset_pattern");
  Deno.exit(1);
}

const [repo, tag, pattern] = args._;
const [owner, repoName] = repo.toString().split("/");

if (!owner || !repoName) {
  console.error("Repository must be in format owner/repo");
  Deno.exit(1);
}

// TODO: add debug mode w/ verbose output to stderr
// TODO: handle enterprise GH
generateDotSlashManifest(owner, repoName, tag.toString(), pattern.toString())
  .catch(console.error);
